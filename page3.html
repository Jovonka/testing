<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Emotion Bubbles with Glassy Metaballs</title>
<style>
  body, html {
    margin: 0;
    padding: 0;
    overflow: hidden;
    height: 100%;
    width: 100%;
    font-family: sans-serif;
    background: black;
  }
  .background-canvas {
    position: absolute;
    top: 0; left: 0;
    width: 100%;
    height: 100%;
    display: block;
    z-index: 0;
  }
  .bubble {
    position: absolute;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    padding: 10px 20px;
    color: white;
    font-weight: bold;
    pointer-events: auto;
    text-align: center;
    z-index: 1;
    user-select: none;
    cursor: pointer;
    transition: transform 0.5s, opacity 0.5s;
  }
  #verseContainer {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    color: white;
    max-width: 80%;
    z-index: 2;
    opacity: 0;
    transition: opacity 1s;
  }
  #verseContainer h1 { margin-bottom: 20px; }
  .hamburger {
    position: absolute;
    top: 2vh;
    left: 2vw;
    width: 35px;
    height: 30px;
    cursor: pointer;
    z-index: 999;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
  }
  .hamburger div { height: 4px; background: #a64b00; border-radius: 2px; transition: all 0.3s ease; }
  .hamburger.open div:nth-child(1) { transform: rotate(45deg) translate(5px, 6px); }
  .hamburger.open div:nth-child(2) { opacity: 0; }
  .hamburger.open div:nth-child(3) { transform: rotate(-45deg) translate(6px, -6px); }

  .side-menu {
    position: fixed;
    top: 0;
    left: -250px;
    width: 220px;
    height: 100%;
    background: rgba(255, 255, 255, 0.9);
    box-shadow: 2px 0 10px rgba(0,0,0,0.1);
    backdrop-filter: blur(6px);
    transition: left 0.3s ease;
    display: flex;
    flex-direction: column;
    padding-top: 60px;
    z-index: 9999;
  }
  .side-menu.open { left: 0; }
  .side-menu a {
    text-decoration: none;
    color: #a64b00;
    font-size: 1.2rem;
    padding: 15px 20px;
    border-bottom: 1px solid rgba(0,0,0,0.05);
    transition: background 0.2s ease;
  }
  .side-menu a:hover { background: rgba(255, 204, 103, 0.3); }

  .content {
    text-align: center;
    color: #a64b00;
    font-size: 1.5rem;
    margin-top: 60px;
  }

  /* Planting area */
  .ground {
    width: 300px;
    height: 100px;
    background: #7cfc00;
    border-radius: 10px;
    position: relative;
    margin-top: 50px;
  }

  .seed {
    width: 30px;
    height: 30px;
    background: brown;
    border-radius: 50%;
    position: absolute;
    top: 20px;
    left: calc(50% - 15px);
    cursor: grab;
  }

  .plant {
    width: 0;
    height: 0;
    background: green;
    position: absolute;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    border-radius: 10px;
    display: none;
    transition: height 2s ease;
  }

  .scripture-box {
    margin-top: 30px;
    background-color: rgba(255, 255, 255, 0.9);
    padding: 20px;
    border: 2px solid #a64b00;
    border-radius: 15px;
    max-width: 500px;
    text-align: center;
    display: none;
  }
</style>
</head>
<body>

<div class="hamburger" id="hamburger">
  <div></div>
  <div></div>
  <div></div>
</div>

<nav class="side-menu" id="sideMenu">
  <a href="index.html">Page 1</a>
  <a href="page2.html">Page 2</a>
  <a href="page3.html">Page 3</a>
  <a href="page4.html">Page 4</a>
</nav>

<canvas class="background-canvas"></canvas>
<div id="verseContainer">
  <h1 id="emotionName"></h1>
  <div id="verseText"></div>
</div>

<script>
window.addEventListener('load', () => {
  const canvas = document.querySelector('.background-canvas');
  const gl = canvas.getContext("webgl");
  if (!gl) { console.error("WebGL not supported"); return; }

  let width = canvas.width = window.innerWidth;
  let height = canvas.height = window.innerHeight;

  window.addEventListener("resize", () => {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    gl.viewport(0, 0, width, height);
  });

  let mouse = { x: width / 2, y: height / 2 };
  window.addEventListener("mousemove", e => { mouse.x = e.clientX; mouse.y = e.clientY; });

  const circleColors = [
    [0.1, 0.45, 0.9],
    [0.87, 0.29, 0.9],
    [0.4, 0.86, 1.0],
    [0.8, 0.2, 0.2],
    [0.7, 0.7, 0.2],
    [0.55, 0.4, 1.0],
  ];

  let circles = [];
  function initCircles() {
    circles = [];
    const baseRadius = (width + height) * 0.2;
    for (let i = 0; i < 5; i++) {
      const radius = baseRadius;
      let x = Math.random() * width;
      let y = Math.random() * height;

      // simple spacing for initial metaballs
      for (let j = 0; j < i; j++) {
        const other = circles[j];
        const dx = other.x - x;
        const dy = other.y - y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < radius) {
          x += radius; y += radius;
        }
      }

      const speedMultiplier = Math.random() * 4 + 1;
      const vx = (Math.random()-0.5) * speedMultiplier;
      const vy = (Math.random()-0.5) * speedMultiplier;
      circles.push({ x, y, radius, color: circleColors[i], vx, vy, interactive: false });
    }
    const interactiveRadius = (width + height) * 0.1;
    circles.push({ x: width/2, y: height/2, radius: interactiveRadius, color: circleColors[5], vx:0, vy:0, interactive:true });
  }
  initCircles();

  // shaders (vertex & fragment)
  const vertexSrc = `
    attribute vec2 a_position;
    varying vec2 v_uv;
    void main(void) {
      v_uv = a_position * 0.5 + 0.5;
      v_uv.y = 1.0 - v_uv.y;
      gl_Position = vec4(a_position, 0.0, 1.0);
    }`;
  
  const fragmentSrc = `
precision mediump float;
varying vec2 v_uv;
uniform vec2 u_resolution;
uniform int u_circleCount;
uniform vec3 u_circlesColor[6];
uniform vec3 u_circlesPosRad[6];
void main(void){
  vec2 st = v_uv*u_resolution;
  vec3 bg = mix(vec3(108.0/255.0,0.0,162.0/255.0), vec3(0.0,17.0/255.0,82.0/255.0), st.y/u_resolution.y);
  float fieldSum=0.0; vec3 weightedColorSum=vec3(0.0);
  for(int i=0;i<6;i++){
    if(i>=u_circleCount) break;
    vec3 posRad = u_circlesPosRad[i];
    vec2 cPos = vec2(posRad.r,posRad.g);
    float radius=posRad.b;
    float dist = length(st-cPos);
    float val = exp(- (dist*dist)/(2.0*radius*0.5*radius*0.5));
    fieldSum += val;
    weightedColorSum += u_circlesColor[i]*val;
  }
  vec3 finalColor = bg;
  if(fieldSum>0.0){
    vec3 metaballColor = mix(vec3(1.0), weightedColorSum/fieldSum, clamp(pow(fieldSum,1.4),0.0,1.0));
    float alpha = clamp(pow(fieldSum,1.4)*0.6,0.25,0.6);
    finalColor = mix(bg, metaballColor, alpha);
  }
  gl_FragColor = vec4(finalColor,1.0);
}`;

  function createShader(type, source){
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)){
      console.error("Shader error:", gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }

  const vertShader = createShader(gl.VERTEX_SHADER, vertexSrc);
  const fragShader = createShader(gl.FRAGMENT_SHADER, fragmentSrc);
  const program = gl.createProgram();
  gl.attachShader(program, vertShader);
  gl.attachShader(program, fragShader);
  gl.linkProgram(program);
  gl.useProgram(program);

  const quadBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]), gl.STATIC_DRAW);

  const a_position = gl.getAttribLocation(program,"a_position");
  gl.enableVertexAttribArray(a_position);
  gl.vertexAttribPointer(a_position,2,gl.FLOAT,false,0,0);

  const u_resolution = gl.getUniformLocation(program,"u_resolution");
  const u_circleCount = gl.getUniformLocation(program,"u_circleCount");
  const u_circlesColor = gl.getUniformLocation(program,"u_circlesColor");
  const u_circlesPosRad = gl.getUniformLocation(program,"u_circlesPosRad");

  function updateCircles(){
    for(let i=0;i<circles.length;i++){
      const c = circles[i];
      if(!c.interactive){
        c.x += c.vx; c.y += c.vy;
        if(c.x - c.radius > width) c.x = -c.radius;
        if(c.x + c.radius < 0) c.x = width+c.radius;
        if(c.y - c.radius > height) c.y = -c.radius;
        if(c.y + c.radius < 0) c.y = height+c.radius;
      } else {
        c.x += (mouse.x - c.x)*0.1;
        c.y += (mouse.y - c.y)*0.1;
      }
    }
  }

  function renderMetaballs(){
    updateCircles();
    gl.viewport(0,0,width,height);
    gl.clearColor(0,0,0,1); gl.clear(gl.COLOR_BUFFER_BIT);
    gl.useProgram(program);
    gl.uniform1i(u_circleCount, circles.length);
    gl.uniform2f(u_resolution,width,height);
    let colorsArr=[], posRadArr=[];
    for(let i=0;i<6;i++){
      if(i<circles.length){
        const c = circles[i];
        colorsArr.push(c.color[0], c.color[1], c.color[2]);
        posRadArr.push(c.x, c.y, c.radius);
      } else { colorsArr.push(0,0,0); posRadArr.push(0,0,0); }
    }
    gl.uniform3fv(u_circlesColor,new Float32Array(colorsArr));
    gl.uniform3fv(u_circlesPosRad,new Float32Array(posRadArr));
    gl.drawArrays(gl.TRIANGLES,0,6);
    requestAnimationFrame(renderMetaballs);
  }
  renderMetaballs();

  const emotions = [
    { name: "Fear", bg: "#3498db", color: "#fff", verse:"But in my distress I cried out to the Lord; yes, I prayed to my God for help. He heard me from his sanctuary; my cry to him reached his ears. Psalm 18:6" },
    { name: "Grief", bg: "#9b59b6", color: "#fff", verse:"But in my distress I cried out to the Lord; yes, I prayed to my God for help. He heard me from his sanctuary; my cry to him reached his ears. Psalm 18:6" },
    { name: "Anger", bg: "#e74c3c", color: "#fff", verse:"But in my distress I cried out to the Lord; yes, I prayed to my God for help. He heard me from his sanctuary; my cry to him reached his ears. Psalm 18:6" },
    { name: "Numbness", bg: "#f39c12", color: "#fff", verse:"But in my distress I cried out to the Lord; yes, I prayed to my God for help. He heard me from his sanctuary; my cry to him reached his ears. Psalm 18:6" }
  ];

  let bubbles = [];
  function initBubbles() {
    bubbles.forEach(b => b.div.remove());
    bubbles = [];

    emotions.forEach(em => {
      const radius = 100;
      let x, y, safe = false;

      while(!safe){
        x = Math.random() * (width - 2*radius) + radius;
        y = Math.random() * (height - 2*radius) + radius;
        safe = true;
        for(let b of bubbles){
          const dx = b.x - x;
          const dy = b.y - y;
          if(Math.sqrt(dx*dx+dy*dy) < b.radius + radius){ safe = false; break; }
        }
      }

      const bubble = { x, y, radius, vx:(Math.random()-0.5)*2, vy:(Math.random()-0.5)*2, ...em };
      const div = document.createElement("div");
      div.className="bubble";
      div.style.background=bubble.bg;
      div.style.color=bubble.color;
      div.style.width=div.style.height=bubble.radius+"px";
      div.innerText=bubble.name;
      document.body.appendChild(div);
      div.addEventListener("click", ()=>{
        bubbles.forEach(b=>{if(b!==bubble) b.div.style.opacity=0;});
        bubble.div.style.transition="opacity 1s, transform 1s";
        bubble.div.style.opacity=0;
        document.getElementById("emotionName").innerText=bubble.name;
        document.getElementById("verseText").innerText=bubble.verse;
        document.getElementById("verseContainer").style.opacity=1;
      });
      bubble.div=div;
      bubbles.push(bubble);
    });
  }
  initBubbles();

  function updateBubbles(){
    bubbles.forEach(b=>{
      b.x += b.vx; b.y += b.vy;
      if(b.x - b.radius/2 <0){b.x=b.radius/2; b.vx*=-1;}
      if(b.x + b.radius/2 > width){b.x=width-b.radius/2; b.vx*=-1;}
      if(b.y - b.radius/2 <0){b.y=b.radius/2; b.vy*=-1;}
      if(b.y + b.radius/2 > height){b.y=height-b.radius/2; b.vy*=-1;}

      // repulsion to prevent overlap
      bubbles.forEach(other=>{
        if(b===other) return;
        const dx = other.x - b.x;
        const dy = other.y - b.y;
        const dist = Math.sqrt(dx*dx+dy*dy);
        const minDist = (b.radius + other.radius)/2;
        if(dist<minDist){
          const angle = Math.atan2(dy, dx);
          const overlap = (minDist - dist)/2;
          b.x -= Math.cos(angle)*overlap;
          b.y -= Math.sin(angle)*overlap;
          other.x += Math.cos(angle)*overlap;
          other.y += Math.sin(angle)*overlap;
        }
      });

      b.div.style.left=(b.x-b.radius/2)+"px";
      b.div.style.top=(b.y-b.radius/2)+"px";
    });
  }
  // --- Hamburger Menu Toggle ---
const hamburger = document.getElementById("hamburger");
const sideMenu = document.getElementById("sideMenu");

hamburger.addEventListener("click", () => {
  hamburger.classList.toggle("open");
  sideMenu.classList.toggle("open");
});


  function animateBubbles(){ updateBubbles(); requestAnimationFrame(animateBubbles);}
  animateBubbles();
});
</script>
</body>
</html>
