<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Trace to Reveal Scripture</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    font-family: Georgia, serif;
    background: rgb(248, 224, 255);
  }
  #verseContainer {
    position: absolute;
    width: 90%;
    max-width: 600px;
    text-align: center;
    font-size: 1.2rem;
    color: #4b2800;
    padding: 20px;
    z-index: 1;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none; /* allow canvas interactions */
  }
  canvas {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 2; /* particles above text */
  }
</style>
</head>
<body>

<div id="verseContainer">
  But in my distress I cried out to the Lord; yes, I prayed to my God for help.<br>
  He heard me from his sanctuary; my cry to him reached his ears.<br>
  <strong>Psalm 18:6</strong>
</div>

<canvas id="c"></canvas>

<script>
(function(w) {

    var canvas, ctx;
    var mouse = { x: 0, y: 0, px: 0, py: 0, down: false };

    var canvas_width = window.innerWidth;
    var canvas_height = window.innerHeight;
    
    var resolution = 10;
    var pen_size = 40;
    var num_cols = Math.ceil(canvas_width / resolution);
    var num_rows = Math.ceil(canvas_height / resolution);
    var speck_count = 3000;
    
    var vec_cells = [];
    var particles = [];

    function init() {
        canvas = document.getElementById("c");
        ctx = canvas.getContext("2d");
        canvas.width = canvas_width;
        canvas.height = canvas_height;

        // create particles
        for (let i = 0; i < speck_count; i++) {
            particles.push(new particle(Math.random() * canvas_width, Math.random() * canvas_height));
        }

        // create grid cells
        for (let col = 0; col < num_cols; col++) {
            vec_cells[col] = [];
            for (let row = 0; row < num_rows; row++) {
                var cell_data = new cell(col * resolution, row * resolution, resolution)
                vec_cells[col][row] = cell_data;
                vec_cells[col][row].col = col;
                vec_cells[col][row].row = row;
            }
        }

        // set neighbors
        for (let col = 0; col < num_cols; col++) {
            for (let row = 0; row < num_rows; row++) {
                let cell_data = vec_cells[col][row];
                let row_up = (row - 1 >= 0) ? row - 1 : num_rows - 1;
                let col_left = (col - 1 >= 0) ? col - 1 : num_cols - 1;
                let col_right = (col + 1 < num_cols) ? col + 1 : 0;
                let up = vec_cells[col][row_up];
                let left = vec_cells[col_left][row];
                let up_left = vec_cells[col_left][row_up];
                let up_right = vec_cells[col_right][row_up];
                cell_data.up = up; cell_data.left = left; cell_data.up_left = up_left; cell_data.up_right = up_right;
                up.down = cell_data; left.right = cell_data; up_left.down_right = cell_data; up_right.down_left = cell_data;
            }
        }

        // events
        w.addEventListener("mousedown", ()=>mouse.down = true);
        w.addEventListener("mouseup", ()=>mouse.down = false);
        w.addEventListener("mousemove", mouse_move_handler);
        w.addEventListener("touchstart", touch_start_handler);
        w.addEventListener("touchmove", touch_move_handler);
        w.addEventListener("touchend", ()=>mouse.down = false);

        draw();
    }

    function mouse_move_handler(e) {
        mouse.px = mouse.x; mouse.py = mouse.y;
        mouse.x = e.clientX; mouse.y = e.clientY;
    }

    function touch_start_handler(e) {
        let rect = canvas.getBoundingClientRect();
        mouse.x = mouse.px = e.touches[0].clientX - rect.left;
        mouse.y = mouse.py = e.touches[0].clientY - rect.top;
        mouse.down = true;
    }
    function touch_move_handler(e) {
        let rect = canvas.getBoundingClientRect();
        mouse.px = mouse.x; mouse.py = mouse.y;
        mouse.x = e.touches[0].clientX - rect.left;
        mouse.y = e.touches[0].clientY - rect.top;
    }

    function cell(x, y, res) {
        this.x = x; this.y = y; this.r = res;
        this.col = 0; this.row = 0;
        this.xv = 0; this.yv = 0;
        this.pressure = 0;
    }

    function particle(x, y) {
        this.x = this.px = x;
        this.y = this.py = y;
        this.xv = this.yv = 0;
    }

    function change_cell_velocity(cell_data, mvelX, mvelY, pen_size) {
        let dx = cell_data.x - mouse.x;
        let dy = cell_data.y - mouse.y;
        let dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < pen_size) {
            if (dist < 4) dist = pen_size;
            let power = pen_size / dist;
            cell_data.xv += mvelX * power;
            cell_data.yv += mvelY * power;
        }
    }

    function update_pressure(cell_data) {
        let pressure_x = (cell_data.up_left.xv*0.5 + cell_data.left.xv + cell_data.down_left.xv*0.5 - cell_data.up_right.xv*0.5 - cell_data.right.xv - cell_data.down_right.xv*0.5);
        let pressure_y = (cell_data.up_left.yv*0.5 + cell_data.up.yv + cell_data.up_right.yv*0.5 - cell_data.down_left.yv*0.5 - cell_data.down.yv - cell_data.down_right.yv*0.5);
        cell_data.pressure = (pressure_x + pressure_y) * 0.25;
    }

    function update_velocity(cell_data) {
        cell_data.xv += (cell_data.up_left.pressure*0.5 + cell_data.left.pressure + cell_data.down_left.pressure*0.5 - cell_data.up_right.pressure*0.5 - cell_data.right.pressure - cell_data.down_right.pressure*0.5)*0.25;
        cell_data.yv += (cell_data.up_left.pressure*0.5 + cell_data.up.pressure + cell_data.up_right.pressure*0.5 - cell_data.down_left.pressure*0.5 - cell_data.down.pressure - cell_data.down_right.pressure*0.5)*0.25;
        cell_data.xv *= 0.99;
        cell_data.yv *= 0.99;
    }

    function update_particle() {
        for (let i=0;i<particles.length;i++){
            let p=particles[i];
            if(p.x>=0 && p.x<canvas_width && p.y>=0 && p.y<canvas_height){
                let col = Math.floor(p.x/resolution);
                let row = Math.floor(p.y/resolution);
                let cell_data = vec_cells[col][row];
                let ax = (p.x % resolution)/resolution;
                let ay = (p.y % resolution)/resolution;
                p.xv += (1-ax)*cell_data.xv*0.05 + ax*cell_data.right.xv*0.05;
                p.yv += (1-ay)*cell_data.yv*0.05 + ay*cell_data.down.yv*0.05;
                p.x += p.xv;
                p.y += p.yv;
                p.xv *= 0.5;
                p.yv *= 0.5;
                p.px = p.x;
                p.py = p.y;
            } else {
                p.x = p.px = Math.random()*canvas_width;
                p.y = p.py = Math.random()*canvas_height;
                p.xv=0; p.yv=0;
            }
        }
    }

    function draw() {
        let mouse_xv = mouse.x - mouse.px;
        let mouse_yv = mouse.y - mouse.py;

        for (let i=0;i<vec_cells.length;i++){
            for (let j=0;j<vec_cells[i].length;j++){
                let cell_data = vec_cells[i][j];
                if(mouse.down) change_cell_velocity(cell_data, mouse_xv, mouse_yv, pen_size);
                update_pressure(cell_data);
            }
        }

        ctx.clearRect(0,0,canvas_width,canvas_height);
        ctx.strokeStyle = "#8B4513";
        update_particle();
        for (let i=0;i<vec_cells.length;i++){
            for (let j=0;j<vec_cells[i].length;j++){
                update_velocity(vec_cells[i][j]);
            }
        }

        mouse.px = mouse.x;
        mouse.py = mouse.y;
        requestAnimationFrame(draw);
    }

    w.Fluid = { initialize: init }

}(window));

window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;
Fluid.initialize();
</script>

</body>
</html>
